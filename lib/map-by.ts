type AnyFn = (...args: any[]) => any

export function mapBy<T, R>(fn: (el: T) => R): (list: T[]) => Map<R, T>
export function mapBy<T, R>(fn: (el: T) => R, list: T[]): Map<R, T>
export function mapBy<T>(
	fn: (el: T) => any
): (list: T[]) => Map<ReturnType<typeof fn>, T>

/**
 * Creates a `Map` from a list of elements, where the keys are generated by a
 * provided function and the values are the elements themselves.
 *
 * This function can be used in a curried style.
 *
 * @template T - The type of the elements in the input list.
 * @template R - The type of the keys in the resulting `Map`.
 * @param {(el: T) => R} fn - A function that takes an element and returns a key for the `Map`.
 * @param {T[]} [list] - The list of elements to transform into a `Map`. If not provided,
 *   the function returns a curried version that takes the list as its argument.
 * @returns {Map<R, T> | ((list: T[]) => Map<R, T>)} A `Map` where keys are the result of
 *   applying `fn` to each element, and values are the original elements. If `list` is
 *   not provided, it returns a function that will do this.
 *
 * @example
 * import { mapBy } from './map-by';
 *
 * const people = [
 *   { id: 1, name: 'Alice' },
 *   { id: 2, name: 'Bob' },
 *   { id: 3, name: 'Charlie' },
 * ];
 *
 * // Create a map by person's ID
 * const peopleById = mapBy(person => person.id, people);
 * // Map { 1 => { id: 1, name: 'Alice' }, 2 => { id: 2, name: 'Bob' }, ... }
 *
 * console.log(peopleById.get(2)); // { id: 2, name: 'Bob' }
 *
 * // Using the curried version
 * const mapById = mapBy((person: { id: number }) => person.id);
 * const peopleByIdCurried = mapById(people);
 *
 * console.log(peopleByIdCurried.get(3)); // { id: 3, name: 'Charlie' }
 *
 * // If multiple elements produce the same key, the last one wins
 * const items = [
 *   { key: 'a', value: 1 },
 *   { key: 'b', value: 2 },
 *   { key: 'a', value: 3 },
 * ];
 *
 * const itemsByKey = mapBy(item => item.key, items);
 * console.log(itemsByKey.get('a')); // { key: 'a', value: 3 }
 */
export function mapBy(fn: AnyFn, list?: any[]): any {
	if (list === undefined) {
		return (list: any[]) => mapBy(fn, list)
	} else {
		const result = new Map()
		for (const el of list) {
			result.set(fn(el), el)
		}
		return result
	}
}
